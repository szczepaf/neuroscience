import numpy as np

class GraphGenerator:


    def Kaiser_and_Hilgetag(self,alpha, beta=0.5, N=100):
        """Return the adjacency matrix of the network generated by the first method (Kaiser and Hilgetag)."""
        adjacency_matrix = np.zeros((N, N)) # position (i, j) says node i connects to node j
        coordinates = np.zeros((N, 2))
        # initialize the first node at 0.5, as in the paper (well it was 2D in the paper, but kinda)
        coordinates[0] = np.array([0.5, 0.5])
        current_N = 1
        while(current_N < N):
            new_coordinate = np.random.random(2)
            # try to connect to existing nodes and track if the new node survives
            connected = False 
            for i in range(current_N):
                distance = np.linalg.norm(coordinates[i] - new_coordinate)
                connection_probability = beta * np.exp(-alpha * distance)
                # draw a random number to decide whether to connect or not
                threshold = np.random.random()
                if threshold < connection_probability:
                    adjacency_matrix[current_N, i] = 1
                    adjacency_matrix[i, current_N] = 1
                    connected = True

            if connected: # only add the new node if it connected to at least one existing node
                coordinates[current_N] = new_coordinate
                current_N += 1

        
        return adjacency_matrix

    def Vertes(self, alpha, N=100, density=0.1):
        """Return the adjacency matrix and weight matrix of the network generated by the second method (Vertes et al.)."""
        adjacency_matrix, weight_matrix = np.zeros((N, N)), np.zeros((N, N)) # position (i, j) says node i connects to node j, this time, directed and weighted
        coordinates = np.random.random((N, 2)) # initialize the coordinates
        # compute the distance and probability matrix
        probability_matrix = np.zeros((N, N))


        # Pairwise Euclidean distances 
        diff = coordinates[:, None, :] - coordinates[None, :, :]
        dist = np.linalg.norm(diff, axis=-1)
        # prob matrix
        probability_matrix = np.exp(-alpha * dist)
        # diagonal should be zero, but still
        np.fill_diagonal(probability_matrix, 0.0) 

        # normalize the probability matrix so it sums to 1
        probability_matrix = probability_matrix / np.sum(probability_matrix)
        # flatten so we can draw from it easily
        probability_vector = probability_matrix.flatten()

        # now start adding the edges until we reach the desired density (dont divide by two as the g is dir)
        target_E = int(density * N * (N - 1))
        curr_E = 0
        while curr_E < target_E:
            # draw from the probability vector
            edge_index = np.random.choice(N * N, p=probability_vector) # probs for loops are 0, so we dont need to check loops
            i, j = edge_index // N, edge_index % N
            # only increase curr E if a new edge has been placed, otherwise, its just a weight incrrease
            curr_E += adjacency_matrix[i, j] == 0
            adjacency_matrix[i, j] = 1  #add a directed edge from i to j (weights are number of edges) 
            weight_matrix[i, j] += 1
            

        # TODO: optimize this function later if needed
        return adjacency_matrix, weight_matrix








    

                




        


        


